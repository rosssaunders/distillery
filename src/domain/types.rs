use serde::{Deserialize, Serialize};

/// The complete story generated by the LLM
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Story {
    pub summary: String,
    pub focus: Focus,
    pub narrative: Vec<Feature>,
    pub data: PrStats,
    pub open_questions: Vec<String>,
    pub suggested_changes: String,
    pub clarification_questions: String,
    pub next_pr: String,
}

/// A logical feature/concern grouping changes
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Feature {
    pub title: String,
    pub why: String,
    pub changes: Vec<String>,
    pub risks: Vec<String>,
    pub tests: Vec<String>,
    pub diff_blocks: Vec<DiffBlock>,
}

/// A diff block with context explaining why
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DiffBlock {
    pub label: String,
    pub role: DiffRole,
    pub significance: Significance,
    pub context: String,
    pub hunks: Vec<Hunk>,
}

/// The role of a diff block in the dependency chain
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "lowercase")]
pub enum DiffRole {
    Root,
    Downstream,
    Supporting,
}

/// The significance of a change - orthogonal to DiffRole
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "lowercase")]
pub enum Significance {
    Key,      // Core business logic - THE point of the PR
    Standard, // Normal changes needing review
    Noise,    // Mechanical: imports, formatting, boilerplate
}

/// Focus section telling reviewers where to spend time
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Focus {
    pub key_change: String,        // One-liner: what IS the key change
    pub review_these: Vec<String>, // Specific files/functions to focus on
    pub skim_these: Vec<String>,   // What can be quickly scanned
}

impl DiffRole {
    pub fn as_str(&self) -> &'static str {
        match self {
            DiffRole::Root => "root",
            DiffRole::Downstream => "downstream",
            DiffRole::Supporting => "supporting",
        }
    }
}

/// A single hunk within a diff block
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Hunk {
    pub header: String,
    pub lines: String,
}

/// Statistics about the PR
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PrStats {
    pub files_touched: u32,
    pub additions: u32,
    pub deletions: u32,
}

/// PR metadata fetched from GitHub
#[derive(Debug, Clone)]
pub struct PrContext {
    pub owner: String,
    pub repo: String,
    pub number: u32,
    pub title: String,
    pub body: String,
    pub diff: String,
    pub author: String,
    pub base_branch: String,
    pub head_branch: String,
}

/// The three review actions
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ReviewAction {
    RequestChanges,
    ClarificationQuestions,
    NextPr,
}

/// A PR in the picker list
#[derive(Debug, Clone)]
pub struct PrListItem {
    pub number: u32,
    pub title: String,
    pub author: String,
    pub head_branch: String,
    pub is_draft: bool,
    pub review_requested: bool,
    pub ci_status: CiStatus,
    pub additions: u32,
    pub deletions: u32,
}

/// A repository in the repo selector
#[derive(Debug, Clone)]
pub struct RepoListItem {
    pub owner: String,
    pub name: String,
    pub description: String,
    pub is_fork: bool,
    pub is_private: bool,
}

/// CI/build status for a PR
#[derive(Debug, Clone, PartialEq)]
pub enum CiStatus {
    Pending,
    Success,
    Failure,
    Unknown,
}

impl CiStatus {
    pub fn symbol(&self) -> &'static str {
        match self {
            CiStatus::Pending => "○",
            CiStatus::Success => "✓",
            CiStatus::Failure => "✗",
            CiStatus::Unknown => "?",
        }
    }
}

impl ReviewAction {
    pub fn title(&self) -> &'static str {
        match self {
            ReviewAction::RequestChanges => "Request Changes",
            ReviewAction::ClarificationQuestions => "Clarification Questions",
            ReviewAction::NextPr => "Next PR",
        }
    }
}
